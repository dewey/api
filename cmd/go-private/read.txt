package tls // import "2a.pages.dev/tls"

Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3,
as specified in RFC 8446.

CONSTANTS

const (
	// TLS 1.0 - 1.2 cipher suites.
	TLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f
	TLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035
	TLS_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0x009c
	TLS_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0x009d
	TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    uint16 = 0xc009
	TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    uint16 = 0xc00a
	TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013
	TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014
	TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f
	TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b
	TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   uint16 = 0xc030
	TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c
	TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305    uint16 = 0xcca8
	TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305  uint16 = 0xcca9
)
    A list of cipher suite IDs that are, or have been, implemented by this
    package.

    Taken from
    https://www.iana.org/assignments/tls-parameters/tls-parameters.xml

const (
	PointFormatUncompressed uint8 = 0
)
    TLS Elliptic Curve Point Formats
    https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9


TYPES

type ALPNExtension struct {
	AlpnProtocols []string
}

func (e *ALPNExtension) Len() int

func (e *ALPNExtension) Read(b []byte) (int, error)

type CipherSuite struct {
	Id uint16
	// the lengths, in bytes, of the key material needed for each component.
	KeyLen int
	MacLen int
	IvLen  int
	Ka     func(version uint16) keyAgreement
	// flags is a bitmask of the suite* values, above.
	Flags  int
	Cipher func(key, iv []byte, isRead bool) interface{}
	Mac    func(version uint16, macKey []byte) macFunction
	Aead   func(key, fixedNonce []byte) aead
}
    A CipherSuite is a specific combination of key agreement, cipher and MAC
    function. All cipher suites currently assume RSA key agreement.

type ClientAuthType int
    ClientAuthType declares the policy the server will follow for TLS Client
    Authentication.

const (
	NoClientCert ClientAuthType = iota
	RequestClientCert
	RequireAnyClientCert
	VerifyClientCertIfGiven
	RequireAndVerifyClientCert
)
type ClientHandshakeState struct {
	C            *Conn
	ServerHello  *ServerHelloMsg
	Hello        *ClientHelloMsg
	MasterSecret []byte
	Session      *ClientSessionState

	State12 TLS12OnlyState

	// Has unexported fields.
}
    ClientHandshakeState includes both TLS 1.3-only and TLS 1.2-only states,
    only one of them will be used, depending on negotiated version.

    ClientHandshakeState will be converted into and from either
      - clientHandshakeState (TLS 1.2)
      - clientHandshakeStateTLS13 (TLS 1.3)

    uTLS will call .handshake() on one of these private internal states,
    to perform TLS handshake using standard crypto/tls implementation.

type ClientHelloInfo struct {
	// CipherSuites lists the CipherSuites supported by the client (e.g.
	// TLS_RSA_WITH_RC4_128_SHA).
	CipherSuites []uint16

	// ServerName indicates the name of the server requested by the client
	// in order to support virtual hosting. ServerName is only set if the
	// client is using SNI (see RFC 4366, Section 3.1).
	ServerName string

	// SupportedCurves lists the elliptic curves supported by the client.
	// SupportedCurves is set only if the Supported Elliptic Curves
	// Extension is being used (see RFC 4492, Section 5.1.1).
	SupportedCurves []CurveID

	// SupportedPoints lists the point formats supported by the client.
	// SupportedPoints is set only if the Supported Point Formats Extension
	// is being used (see RFC 4492, Section 5.1.2).
	SupportedPoints []uint8

	// SignatureSchemes lists the signature and hash schemes that the client
	// is willing to verify. SignatureSchemes is set only if the Signature
	// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).
	SignatureSchemes []SignatureScheme

	// SupportedProtos lists the application protocols supported by the client.
	// SupportedProtos is set only if the Application-Layer Protocol
	// Negotiation Extension is being used (see RFC 7301, Section 3.1).
	//
	// Servers can select a protocol by setting Config.NextProtos in a
	// GetConfigForClient return value.
	SupportedProtos []string

	// SupportedVersions lists the TLS versions supported by the client.
	// For TLS versions less than 1.3, this is extrapolated from the max
	// version advertised by the client, so values other than the greatest
	// might be rejected if used.
	SupportedVersions []uint16

	// Conn is the underlying net.Conn for the connection. Do not read
	// from, or write to, this connection; that will cause the TLS
	// connection to fail.
	Conn net.Conn
}
    ClientHelloInfo contains information from a ClientHello message in order to
    guide certificate selection in the GetCertificate callback.

type ClientHelloMsg struct {
	Raw                          []byte
	Vers                         uint16
	Random                       []byte
	SessionId                    []byte
	CipherSuites                 []uint16
	CompressionMethods           []uint8
	NextProtoNeg                 bool
	ServerName                   string
	OcspStapling                 bool
	Scts                         bool
	Ems                          bool // [UTLS] actually implemented due to its prevalence
	SupportedCurves              []CurveID
	SupportedPoints              []uint8
	TicketSupported              bool
	SessionTicket                []uint8
	SupportedSignatureAlgorithms []SignatureScheme
	SecureRenegotiation          []byte
	SecureRenegotiationSupported bool
	AlpnProtocols                []string

	// 1.3
	SupportedSignatureAlgorithmsCert []SignatureScheme
	SupportedVersions                []uint16
	Cookie                           []byte
	KeyShares                        []KeyShare
	EarlyData                        bool
	PskModes                         []uint8
	PskIdentities                    []pskIdentity
	PskBinders                       [][]byte
}

type ClientHelloSpec struct {
	CipherSuites       []uint16       // nil => default
	CompressionMethods []uint8        // nil => no compression
	Extensions         []TLSExtension // nil => no extensions

	TLSVersMin uint16 // [1.0-1.3] default: parse from .Extensions, if SupportedVersions ext is not present => 1.0
	TLSVersMax uint16 // [1.2-1.3] default: parse from .Extensions, if SupportedVersions ext is not present => 1.2

	// GreaseStyle: currently only random
	// sessionID may or may not depend on ticket; nil => random
	GetSessionID func(ticket []byte) [32]byte
}

type ClientSessionCache interface {
	// Get searches for a ClientSessionState associated with the given key.
	// On return, ok is true if one was found.
	Get(sessionKey string) (session *ClientSessionState, ok bool)

	// Put adds the ClientSessionState to the cache with the given key. It might
	// get called multiple times in a connection if a TLS 1.3 server provides
	// more than one session ticket. If called with a nil *ClientSessionState,
	// it should remove the cache entry.
	Put(sessionKey string, cs *ClientSessionState)
}
    ClientSessionCache is a cache of ClientSessionState objects that can be used
    by a client to resume a TLS session with a given server. ClientSessionCache
    implementations should expect to be called concurrently from different
    goroutines. Up to TLS 1.2, only ticket-based resumption is supported,
    not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes,
    which are supported via this interface.

func NewLRUClientSessionCache(capacity int) ClientSessionCache
    NewLRUClientSessionCache returns a ClientSessionCache with the given
    capacity that uses an LRU strategy. If capacity is < 1, a default capacity
    is used instead.

type ClientSessionState struct {
	// Has unexported fields.
}
    ClientSessionState contains the state needed by clients to resume TLS
    sessions.

func MakeClientSessionState(
	SessionTicket []uint8,
	Vers uint16,
	CipherSuite uint16,
	MasterSecret []byte,
	ServerCertificates []*x509.Certificate,
	VerifiedChains [][]*x509.Certificate) *ClientSessionState
    ClientSessionState contains the state needed by clients to resume TLS
    sessions.

func (css *ClientSessionState) CipherSuite() uint16
    Ciphersuite negotiated for the session

func (css *ClientSessionState) MasterSecret() []byte
    MasterSecret generated by client on a full handshake

func (css *ClientSessionState) ServerCertificates() []*x509.Certificate
    Certificate chain presented by the server

func (css *ClientSessionState) SessionTicket() []uint8
    Encrypted ticket used for session resumption with server

func (css *ClientSessionState) SetCipherSuite(CipherSuite uint16)

func (css *ClientSessionState) SetMasterSecret(MasterSecret []byte)

func (css *ClientSessionState) SetServerCertificates(ServerCertificates []*x509.Certificate)

func (css *ClientSessionState) SetSessionTicket(SessionTicket []uint8)

func (css *ClientSessionState) SetVerifiedChains(VerifiedChains [][]*x509.Certificate)

func (css *ClientSessionState) SetVers(Vers uint16)

func (css *ClientSessionState) VerifiedChains() [][]*x509.Certificate
    Certificate chains we built for verification

func (css *ClientSessionState) Vers() uint16
    SSL/TLS version negotiated for the session

type Config struct {
	// Rand provides the source of entropy for nonces and RSA blinding.
	// If Rand is nil, TLS uses the cryptographic random reader in package
	// crypto/rand.
	// The Reader must be safe for use by multiple goroutines.
	Rand io.Reader

	// Time returns the current time as the number of seconds since the epoch.
	// If Time is nil, TLS uses time.Now.
	Time func() time.Time

	// Certificates contains one or more certificate chains to present to
	// the other side of the connection. Server configurations must include
	// at least one certificate or else set GetCertificate. Clients doing
	// client-authentication may set either Certificates or
	// GetClientCertificate.
	Certificates []certificate

	// NameToCertificate maps from a certificate name to an element of
	// Certificates. Note that a certificate name can be of the form
	// '*.example.com' and so doesn't have to be a domain name as such.
	// See Config.BuildNameToCertificate
	// The nil value causes the first element of Certificates to be used
	// for all connections.
	NameToCertificate map[string]*certificate

	// GetCertificate returns a Certificate based on the given
	// ClientHelloInfo. It will only be called if the client supplies SNI
	// information or if Certificates is empty.
	//
	// If GetCertificate is nil or returns nil, then the certificate is
	// retrieved from NameToCertificate. If NameToCertificate is nil, the
	// first element of Certificates will be used.
	GetCertificate func(*ClientHelloInfo) (*certificate, error)

	// GetConfigForClient, if not nil, is called after a ClientHello is
	// received from a client. It may return a non-nil Config in order to
	// change the Config that will be used to handle this connection. If
	// the returned Config is nil, the original Config will be used. The
	// Config returned by this callback may not be subsequently modified.
	//
	// If GetConfigForClient is nil, the Config passed to Server() will be
	// used for all connections.
	//
	// Uniquely for the fields in the returned Config, session ticket keys
	// will be duplicated from the original Config if not set.
	// Specifically, if SetSessionTicketKeys was called on the original
	// config but not on the returned config then the ticket keys from the
	// original config will be copied into the new config before use.
	// Otherwise, if SessionTicketKey was set in the original config but
	// not in the returned config then it will be copied into the returned
	// config before use. If neither of those cases applies then the key
	// material from the returned config will be used for session tickets.
	GetConfigForClient func(*ClientHelloInfo) (*Config, error)

	// VerifyPeerCertificate, if not nil, is called after normal
	// certificate verification by either a TLS client or server. It
	// receives the raw ASN.1 certificates provided by the peer and also
	// any verified chains that normal processing found. If it returns a
	// non-nil error, the handshake is aborted and that error results.
	//
	// If normal verification fails then the handshake will abort before
	// considering this callback. If normal verification is disabled by
	// setting InsecureSkipVerify, or (for a server) when ClientAuth is
	// RequestClientCert or RequireAnyClientCert, then this callback will
	// be considered but the verifiedChains argument will always be nil.
	VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error

	// RootCAs defines the set of root certificate authorities
	// that clients use when verifying server certificates.
	// If RootCAs is nil, TLS uses the host's root CA set.
	RootCAs *x509.CertPool

	// NextProtos is a list of supported application level protocols, in
	// order of preference.
	NextProtos []string

	// ServerName is used to verify the hostname on the returned
	// certificates unless InsecureSkipVerify is given. It is also included
	// in the client's handshake to support virtual hosting unless it is
	// an IP address.
	ServerName string

	// ClientAuth determines the server's policy for
	// TLS Client Authentication. The default is NoClientCert.
	ClientAuth ClientAuthType

	// ClientCAs defines the set of root certificate authorities
	// that servers use if required to verify a client certificate
	// by the policy in ClientAuth.
	ClientCAs *x509.CertPool

	// InsecureSkipVerify controls whether a client verifies the
	// server's certificate chain and host name.
	// If InsecureSkipVerify is true, TLS accepts any certificate
	// presented by the server and any host name in that certificate.
	// In this mode, TLS is susceptible to man-in-the-middle attacks.
	// This should be used only for testing.
	InsecureSkipVerify bool

	// CipherSuites is a list of supported cipher suites. If CipherSuites
	// is nil, TLS uses a list of suites supported by the implementation.
	CipherSuites []uint16

	// PreferServerCipherSuites controls whether the server selects the
	// client's most preferred ciphersuite, or the server's most preferred
	// ciphersuite. If true then the server's preference, as expressed in
	// the order of elements in CipherSuites, is used.
	PreferServerCipherSuites bool

	// SessionTicketsDisabled may be set to true to disable session ticket and
	// PSK (resumption) support. Note that on clients, session ticket support is
	// also disabled if ClientSessionCache is nil.
	SessionTicketsDisabled bool

	// SessionTicketKey is used by TLS servers to provide session resumption.
	// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled
	// with random data before the first server handshake.
	//
	// If multiple servers are terminating connections for the same host
	// they should all have the same SessionTicketKey. If the
	// SessionTicketKey leaks, previously recorded and future TLS
	// connections using that key might be compromised.
	SessionTicketKey [32]byte

	// ClientSessionCache is a cache of ClientSessionState entries for TLS
	// session resumption. It is only used by clients.
	ClientSessionCache ClientSessionCache

	// MinVersion contains the minimum SSL/TLS version that is acceptable.
	// If zero, then TLS 1.0 is taken as the minimum.
	MinVersion uint16

	// MaxVersion contains the maximum SSL/TLS version that is acceptable.
	// If zero, then the maximum version supported by this package is used,
	// which is currently TLS 1.3.
	MaxVersion uint16

	// CurvePreferences contains the elliptic curves that will be used in
	// an ECDHE handshake, in preference order. If empty, the default will
	// be used. The client will use the first preference as the type for
	// its key share in TLS 1.3. This may change in the future.
	CurvePreferences []CurveID

	// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.
	// When true, the largest possible TLS record size is always used. When
	// false, the size of TLS records may be adjusted in an attempt to
	// improve latency.
	DynamicRecordSizingDisabled bool

	// Renegotiation controls what types of renegotiation are supported.
	// The default, none, is correct for the vast majority of applications.
	Renegotiation RenegotiationSupport

	// KeyLogWriter optionally specifies a destination for TLS master secrets
	// in NSS key log format that can be used to allow external programs
	// such as Wireshark to decrypt TLS connections.
	// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.
	// Use of KeyLogWriter compromises security and should only be
	// used for debugging.
	KeyLogWriter io.Writer

	// Has unexported fields.
}
    A Config structure is used to configure a TLS client or server. After one
    has been passed to a TLS function it must not be modified. A Config may be
    reused; the tls package will also not modify it.

func (c *Config) BuildNameToCertificate()
    BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate
    from the CommonName and SubjectAlternateName fields of each of the leaf
    certificates.

func (c *Config) Clone() *Config
    Clone returns a shallow clone of c. It is safe to clone a Config that is
    being used concurrently by a TLS client or server.

func (c *Config) SetSessionTicketKeys(keys [][32]byte)
    SetSessionTicketKeys updates the session ticket keys for a server. The first
    key will be used when creating new tickets, while all keys can be used for
    decrypting tickets. It is safe to call this function while the server is
    running in order to rotate the session ticket keys. The function will panic
    if keys is empty.

type Conn struct {
	// Has unexported fields.
}
    A Conn represents a secured connection. It implements the net.Conn
    interface.

func Client(conn net.Conn, config *Config) *Conn
    Client returns a new TLS client side connection using conn as the underlying
    transport. The config cannot be nil: users must set either ServerName or
    InsecureSkipVerify in the config.

func Dial(network, addr string, config *Config) (*Conn, error)
    Dial connects to the given network address using net.Dial and then
    initiates a TLS handshake, returning the resulting TLS connection.
    Dial interprets a nil configuration as equivalent to the zero configuration;
    see the documentation of Config for the defaults.

func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)
    DialWithDialer connects to the given network address using dialer.Dial and
    then initiates a TLS handshake, returning the resulting TLS connection.
    Any timeout or deadline given in the dialer apply to connection and TLS
    handshake as a whole.

    DialWithDialer interprets a nil configuration as equivalent to the zero
    configuration; see the documentation of Config for the defaults.

func MakeConnWithCompleteHandshake(tcpConn net.Conn, version uint16, cipherSuite uint16, masterSecret []byte, clientRandom []byte, serverRandom []byte, isClient bool) *Conn
    MakeConnWithCompleteHandshake allows to forge both server and client side
    TLS connections. Major Hack Alert.

func Server(conn net.Conn, config *Config) *Conn
    Server returns a new TLS server side connection using conn as the underlying
    transport. The configuration config must be non-nil and must include at
    least one certificate or else set GetCertificate.

func (c *Conn) Close() error
    Close closes the connection.

func (c *Conn) CloseWrite() error
    CloseWrite shuts down the writing side of the connection. It should only be
    called once the handshake has completed and does not call CloseWrite on the
    underlying connection. Most callers should just use Close.

func (c *Conn) ConnectionState() ConnectionState
    ConnectionState returns basic TLS details about the connection.

func (c *Conn) Handshake() error
    Handshake runs the client or server handshake protocol if it has not yet
    been run. Most uses of this package need not call Handshake explicitly:
    the first Read or Write will call it automatically.

func (c *Conn) LocalAddr() net.Addr
    LocalAddr returns the local network address.

func (c *Conn) OCSPResponse() []byte
    OCSPResponse returns the stapled OCSP response from the TLS server, if any.
    (Only valid for client connections.)

func (c *Conn) Read(b []byte) (int, error)
    Read can be made to time out and return a net.Error with Timeout() == true
    after a fixed time limit; see SetDeadline and SetReadDeadline.

func (c *Conn) RemoteAddr() net.Addr
    RemoteAddr returns the remote network address.

func (c *Conn) SetDeadline(t time.Time) error
    SetDeadline sets the read and write deadlines associated with the
    connection. A zero value for t means Read and Write will not time out.
    After a Write has timed out, the TLS state is corrupt and all future writes
    will return the same error.

func (c *Conn) SetReadDeadline(t time.Time) error
    SetReadDeadline sets the read deadline on the underlying connection.
    A zero value for t means Read will not time out.

func (c *Conn) SetWriteDeadline(t time.Time) error
    SetWriteDeadline sets the write deadline on the underlying connection. A
    zero value for t means Write will not time out. After a Write has timed out,
    the TLS state is corrupt and all future writes will return the same error.

func (c *Conn) VerifyHostname(host string) error
    VerifyHostname checks that the peer certificate chain is valid for
    connecting to host. If so, it returns nil; if not, it returns an error
    describing the problem.

func (c *Conn) Write(b []byte) (int, error)
    Write writes data to the connection.

type ConnectionState struct {
	Version                     uint16                // TLS version used by the connection (e.g. VersionTLS12)
	HandshakeComplete           bool                  // TLS handshake is complete
	DidResume                   bool                  // connection resumes a previous TLS connection
	CipherSuite                 uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)
	NegotiatedProtocol          string                // negotiated next protocol (not guaranteed to be from Config.NextProtos)
	NegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server (client side only)
	ServerName                  string                // server name requested by client, if any (server side only)
	PeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer
	VerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates
	SignedCertificateTimestamps [][]byte              // SCTs from the peer, if any
	OCSPResponse                []byte                // stapled OCSP response from peer, if any

	// TLSUnique contains the "tls-unique" channel binding value (see RFC
	// 5929, section 3). For resumed sessions this value will be nil
	// because resumption does not include enough context (see
	// https://mitls.org/pages/attacks/3SHAKE#channelbindings). This will
	// change in future versions of Go once the TLS master-secret fix has
	// been standardized and implemented. It is not defined in TLS 1.3.
	TLSUnique []byte
	// Has unexported fields.
}
    ConnectionState records basic TLS details about the connection.

func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)
    ExportKeyingMaterial returns length bytes of exported key material in a
    new slice as defined in RFC 5705. If context is nil, it is not used as
    part of the seed. If the connection was set to allow renegotiation via
    Config.Renegotiation, this function will return an error.

type CookieExtension struct {
	Cookie []byte
}
    MUST NOT be part of initial ClientHello

func (e *CookieExtension) Len() int

func (e *CookieExtension) Read(b []byte) (int, error)

type CurveID uint16
    CurveID is the type of a TLS identifier for an elliptic curve. See
    https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.

    In TLS 1.3, this type is called NamedGroup, but at this time this library
    only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.

const (
	CurveP256 CurveID = 23
	CurveP384 CurveID = 24
	CurveP521 CurveID = 25
	X25519    CurveID = 29
)
type FakeCertCompressionAlgsExtension struct {
	Methods []certCompressionAlgo
}

func (e *FakeCertCompressionAlgsExtension) Len() int

func (e *FakeCertCompressionAlgsExtension) Read(b []byte) (int, error)

type FakeChannelIDExtension struct {
}

func (e *FakeChannelIDExtension) Len() int

func (e *FakeChannelIDExtension) Read(b []byte) (int, error)

type FakeRecordSizeLimitExtension struct {
	Limit uint16
}

func (e *FakeRecordSizeLimitExtension) Len() int

func (e *FakeRecordSizeLimitExtension) Read(b []byte) (int, error)

type FinishedHash struct {
	Client hash.Hash
	Server hash.Hash

	// Prior to TLS 1.2, an additional MD5 hash is required.
	ClientMD5 hash.Hash
	ServerMD5 hash.Hash

	// In TLS 1.2, a full buffer is sadly required.
	Buffer []byte

	Version uint16
	Prf     func(result, secret, label, seed []byte)
}
    A FinishedHash calculates the hash of a set of handshake messages suitable
    for including in a Finished message.

type GenericExtension struct {
	Id   uint16
	Data []byte
}
    GenericExtension allows to include in ClientHello arbitrary unsupported
    extensions.

func (e *GenericExtension) Len() int

func (e *GenericExtension) Read(b []byte) (int, error)

type KeyShare struct {
	Group CurveID
	Data  []byte
}
    TLS 1.3 Key Share. See RFC 8446, Section 4.2.8.

type KeyShareExtension struct {
	KeyShares []KeyShare
}
    TLS 1.3

func (e *KeyShareExtension) Len() int

func (e *KeyShareExtension) Read(b []byte) (int, error)

type KeyShares []KeyShare

func (KSS KeyShares) ToPrivate() []keyShare

type NPNExtension struct {
	NextProtos []string
}

func (e *NPNExtension) Len() int

func (e *NPNExtension) Read(b []byte) (int, error)

type PSKKeyExchangeModesExtension struct {
	Modes []uint8
}

func (e *PSKKeyExchangeModesExtension) Len() int

func (e *PSKKeyExchangeModesExtension) Read(b []byte) (int, error)

type RecordHeaderError struct {
	// Msg contains a human readable string that describes the error.
	Msg string
	// RecordHeader contains the five bytes of TLS record header that
	// triggered the error.
	RecordHeader [5]byte
	// Conn provides the underlying net.Conn in the case that a client
	// sent an initial handshake that didn't look like TLS.
	// It is nil if there's already been a handshake or a TLS alert has
	// been written to the connection.
	Conn net.Conn
}
    RecordHeaderError is returned when a TLS record header is invalid.

func (e RecordHeaderError) Error() string

type RenegotiationInfoExtension struct {
	// Renegotiation field limits how many times client will perform renegotiation: no limit, once, or never.
	// The extension still will be sent, even if Renegotiation is set to RenegotiateNever.
	Renegotiation RenegotiationSupport
}

func (e *RenegotiationInfoExtension) Len() int

func (e *RenegotiationInfoExtension) Read(b []byte) (int, error)

type RenegotiationSupport int
    RenegotiationSupport enumerates the different levels of support for TLS
    renegotiation. TLS renegotiation is the act of performing subsequent
    handshakes on a connection after the first. This significantly complicates
    the state machine and has been the source of numerous, subtle security
    issues. Initiating a renegotiation is not supported, but support for
    accepting renegotiation requests may be enabled.

    Even when enabled, the server may not change its identity between handshakes
    (i.e. the leaf certificate must be the same). Additionally, concurrent
    handshake and application data flow is not permitted so renegotiation
    can only be used with protocols that synchronise with the renegotiation,
    such as HTTPS.

    Renegotiation is not defined in TLS 1.3.

const (
	// RenegotiateNever disables renegotiation.
	RenegotiateNever RenegotiationSupport = iota

	// RenegotiateOnceAsClient allows a remote server to request
	// renegotiation once per connection.
	RenegotiateOnceAsClient

	// RenegotiateFreelyAsClient allows a remote server to repeatedly
	// request renegotiation.
	RenegotiateFreelyAsClient
)
type SCTExtension struct {
}

func (e *SCTExtension) Len() int

func (e *SCTExtension) Read(b []byte) (int, error)

type SNIExtension struct {
	ServerName string // not an array because go crypto/tls doesn't support multiple SNIs
}

func (e *SNIExtension) Len() int

func (e *SNIExtension) Read(b []byte) (int, error)

type ServerHelloMsg struct {
	Raw                          []byte
	Vers                         uint16
	Random                       []byte
	SessionId                    []byte
	CipherSuite                  uint16
	CompressionMethod            uint8
	NextProtoNeg                 bool
	NextProtos                   []string
	OcspStapling                 bool
	Scts                         [][]byte
	Ems                          bool
	TicketSupported              bool
	SecureRenegotiation          []byte
	SecureRenegotiationSupported bool
	AlpnProtocol                 string

	// 1.3
	SupportedVersion        uint16
	ServerShare             keyShare
	SelectedIdentityPresent bool
	SelectedIdentity        uint16
	Cookie                  []byte  // HelloRetryRequest extension
	SelectedGroup           CurveID // HelloRetryRequest extension

}

type SessionTicketExtension struct {
	Session *ClientSessionState
}

func (e *SessionTicketExtension) Len() int

func (e *SessionTicketExtension) Read(b []byte) (int, error)

type SignatureAlgorithmsExtension struct {
	SupportedSignatureAlgorithms []SignatureScheme
}

func (e *SignatureAlgorithmsExtension) Len() int

func (e *SignatureAlgorithmsExtension) Read(b []byte) (int, error)

type SignatureScheme uint16
    SignatureScheme identifies a signature algorithm supported by TLS. See RFC
    8446, Section 4.2.3.

const (
	PKCS1WithSHA1   SignatureScheme = 0x0201
	PKCS1WithSHA256 SignatureScheme = 0x0401
	PKCS1WithSHA384 SignatureScheme = 0x0501
	PKCS1WithSHA512 SignatureScheme = 0x0601

	// RSASSA-PSS algorithms with public key OID rsaEncryption.
	PSSWithSHA256 SignatureScheme = 0x0804
	PSSWithSHA384 SignatureScheme = 0x0805
	PSSWithSHA512 SignatureScheme = 0x0806

	ECDSAWithP256AndSHA256 SignatureScheme = 0x0403
	ECDSAWithP384AndSHA384 SignatureScheme = 0x0503
	ECDSAWithP521AndSHA512 SignatureScheme = 0x0603

	// Legacy signature and hash algorithms for TLS 1.2.
	ECDSAWithSHA1 SignatureScheme = 0x0203
)
var (
	FakePKCS1WithSHA224 SignatureScheme = 0x0301
	FakeECDSAWithSHA224 SignatureScheme = 0x0303
)
    newest signatures

type StatusRequestExtension struct {
}

func (e *StatusRequestExtension) Len() int

func (e *StatusRequestExtension) Read(b []byte) (int, error)

type SupportedCurvesExtension struct {
	Curves []CurveID
}

func (e *SupportedCurvesExtension) Len() int

func (e *SupportedCurvesExtension) Read(b []byte) (int, error)

type SupportedPointsExtension struct {
	SupportedPoints []uint8
}

func (e *SupportedPointsExtension) Len() int

func (e *SupportedPointsExtension) Read(b []byte) (int, error)

type SupportedVersionsExtension struct {
	Versions []uint16
}

func (e *SupportedVersionsExtension) Len() int

func (e *SupportedVersionsExtension) Read(b []byte) (int, error)

type TLS12OnlyState struct {
	FinishedHash FinishedHash
	Suite        CipherSuite
}
    TLS 1.2 and before only

type TLSExtension interface {
	Len() int // includes header

	// Read reads up to len(p) bytes into p.
	// It returns the number of bytes read (0 <= n <= len(p)) and any error encountered.
	Read(p []byte) (n int, err error) // implements io.Reader
	// Has unexported methods.
}

type UConn struct {
	*Conn

	Extensions []TLSExtension

	ClientHelloBuilt bool

	// sessionID may or may not depend on ticket; nil => random
	GetSessionID func(ticket []byte) [32]byte

	// Has unexported fields.
}

func UClient(conn net.Conn, config *Config) *UConn
    UClient returns a new uTLS client, with behavior depending on clientHelloID.
    Config CAN be nil, but make sure to eventually specify ServerName.

func (uconn *UConn) ApplyConfig() error

func (uconn *UConn) ApplyPreset(p *ClientHelloSpec) error
    ApplyPreset should only be used in conjunction with HelloCustom to apply
    custom specs. Fields of TLSExtensions that are slices/pointers are shared
    across different connections with same ClientHelloSpec. It is advised to use
    different specs and avoid any shared state.

func (uconn *UConn) BuildHandshakeState() error
    BuildHandshakeState behavior varies based on ClientHelloID and whether it
    was already called before. If HelloGolang:

        [only once] make default ClientHello and overwrite existing state

    If any other mimicking ClientHelloID is used:

        [only once] make ClientHello based on ID and overwrite existing state
        [each call] apply uconn.Extensions config to internal crypto/tls structures
        [each call] marshal ClientHello.

    BuildHandshakeState is automatically called before uTLS performs handshake,
    amd should only be called explicitly to inspect/change fields of
    default/mimicked ClientHello.

func (uconn *UConn) GetOutKeystream(length int) ([]byte, error)
    get current state of cipher and encrypt zeros to get keystream

func (uconn *UConn) GetUnderlyingConn() net.Conn

func (c *UConn) Handshake() error
    Handshake runs the client handshake using given clientHandshakeState
    Requires hs.hello, and, optionally, hs.session to be set.

func (uconn *UConn) MarshalClientHello() error

func (uconn *UConn) SetClientRandom(r []byte) error
    SetClientRandom sets client random explicitly. BuildHandshakeFirst() must be
    called before SetClientRandom. r must to be 32 bytes long.

func (uconn *UConn) SetSNI(sni string)

func (uconn *UConn) SetSessionCache(cache ClientSessionCache)
    If you want session tickets to be reused - use same cache on following
    connections

func (uconn *UConn) SetSessionState(session *ClientSessionState) error
    SetSessionState sets the session ticket, which may be preshared or fake.
    If session is nil, the body of session ticket extension will be unset,
    but the extension itself still MAY be present for mimicking purposes.
    Session tickets to be reused - use same cache on following connections.

func (uconn *UConn) SetTLSVers(minTLSVers, maxTLSVers uint16, specExtensions []TLSExtension) error
    SetTLSVers sets min and max TLS version in all appropriate places. Function
    will use first non-zero version parsed in following order:
     1. Provided minTLSVers, maxTLSVers
     2. specExtensions may have SupportedVersionsExtension
     3. [default] min = TLS 1.0, max = TLS 1.2

    Error is only returned if things are in clearly undesirable state to help
    user fix them.

func (uconn *UConn) SetUnderlyingConn(c net.Conn)

func (c *UConn) Write(b []byte) (int, error)
    Copy-pasted from tls.Conn in its entirety. But c.Handshake() is now utls'
    one, not tls. Write writes data to the connection.

type UtlsExtendedMasterSecretExtension struct {
}

func (e *UtlsExtendedMasterSecretExtension) Len() int

func (e *UtlsExtendedMasterSecretExtension) Read(b []byte) (int, error)

type UtlsGREASEExtension struct {
	Value uint16
	Body  []byte // in Chrome first grease has empty body, second grease has a single zero byte
}
    it is responsibility of user not to generate multiple grease extensions with
    same value

func (e *UtlsGREASEExtension) Len() int

func (e *UtlsGREASEExtension) Read(b []byte) (int, error)

type UtlsPaddingExtension struct {
	PaddingLen int
	WillPad    bool // set to false to disable extension

	// Functor for deciding on padding length based on unpadded ClientHello length.
	// If willPad is false, then this extension should not be included.
	GetPaddingLen func(clientHelloUnpaddedLen int) (paddingLen int, willPad bool)
}

func (e *UtlsPaddingExtension) Len() int

func (e *UtlsPaddingExtension) Read(b []byte) (int, error)

func (e *UtlsPaddingExtension) Update(clientHelloUnpaddedLen int)
